### final关键字的作用

1.修饰类

当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。

2.修饰方法

下面这段话摘自《Java编程思想》第四版第143页：

“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“

因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。

注：类的private方法会隐式地被指定为final方法。

虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。

3.修饰变量

修饰变量是final用得最多的地方，也是本文接下来要重点阐述的内容。首先了解一下final变量的基本语法：

对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

### 内部类
在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。


虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&0引用进行初始化赋值，也就无法创建成员内部类的对象了。

###### 静态内部类
　静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法

静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&0引用的。

###### 匿名内部类
匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。


如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。


内部类的存在使得Java的多继承机制变得更加完善。

*为什么匿名内部类只能够访问final的局部变量: *
```
Java编译器实现的只是capture-by-value，并没有实现capture-by-reference。
```
而只有后者才能保持匿名内部类和外部环境局部变量保持同步。
https://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/

### Java为何引入泛型，泛型边界
泛型系统是作为Java 5的一套增强类型安全及减少显式类型转换的系统出现的。泛型也叫参数化类型，顾名思义，通过给类型赋予一定的泛型参数，来达到提高代码复用度和减少复杂性的目的。

在Java中，泛型是作为语法糖出现的。在虚拟机层面，并不存在泛型这种类型，也不会对泛型进行膨胀，生成出类似于List<String>、List<Entry>之类的类型。在虚拟机看来，List<E>这个泛型类型只是普通的类型List而已，这种行为叫泛型擦除(Type Erasure)。


- 无界通配符为”?”
- 上界通配符：extends
- 下界通配符：super





## 强引用，软引用，弱引用，虚引用

从JDK1.2版本开始，把对象的引用分为四种级别：
- 强引用

只要引用存在，垃圾回收器永远不会回收
Object obj = new Object();
//可直接通过obj取得对应的对象 如obj.equels(new Object());
而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。
当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

- 软引用

非必须引用，内存溢出之前进行回收，可以通过以下代码实现
```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
```
这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
软引用主要用户实现内存敏感的高速缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

解软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。 

- 弱引用

第二次垃圾回收时回收，可以通过如下代码实现
```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
wf.get();//有时候会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

- 虚引用

垃圾回收时回收，无法通过引用取到对象值。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。可以通过如下代码实现
```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```
虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。
虚引用主要用于检测对象是否已经从内存中删除。

虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。


### 为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？
###### equals方法
Object类中默认的实现方式是  :   return this == obj  。那就是说，只有this 和 obj引用同一个对象，才会返回true。

而我们往往需要用equals来判断 2个对象是否等价，而非验证他们的唯一性。这样我们在实现自己的类时，就要重写equals.

- 自反性:  x.equals(x) 一定是true
- 对null:  x.equals(null) 一定是false
- 对称性:  x.equals(y)  和  y.equals(x)结果一致
- 传递性:  a 和 b equals , b 和 c  equals，那么 a 和 c也一定equals。
- 一致性:  在某个运行时期间，2个对象的状态的改变不会影响equals的决策结果，那么，在这个运行时期间，无论调用多少次equals，都返回相同的结果。

###### hashCode方法
这个方法返回对象的散列码，返回值是int类型的散列码。
对象的散列码是为了更好的支持基于哈希机制的Java集合类，例如 Hashtable, HashMap, HashSet 等。   

- 在某个运行时期间，只要对象的（字段的）变化不会影响equals方法的决策结果，那么，在这个期间，无论调用多少次hashCode，都必须返回同一个散列码。
- 如果2个对象通过equals调用后返回是true，那么这个2个对象的has
hCode方法也必须返回同样的int型散列码如果2个对象通过equals返回false，他们的hashCode返回的值允许相同。(然而，程序员必须意识到，hashCode返回独一无二的散列码，会让存储这个对象的hashtables更好地工作。)

重写了euqls方法的对象必须同时重写hashCode()方法。

参与equals函数的字段，也必须都参与hashCode 的计算。

- 当两个对象equals的时候，其hashcode必然相等。
- 当两个对象hashcode相同的时候，两者不必然相等
这个是由于hash算法决定的。我们应该尽力避免两个不同的对象生成相同的hashcode，也就是避免hash冲突,从而提高依赖hashCode的数据结构的读写性能。

### 如何防止JAVA反射对单例类的攻击？
- 使用枚举类型的单例模式
- 修改构造器，让他在被要求创建第二个实例的时候抛出异常。可以简单使用一个flag实现判断。
